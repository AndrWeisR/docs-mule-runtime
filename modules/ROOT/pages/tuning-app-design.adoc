= App Design Performance Best Practices
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

As you design your applications, consider the following best practices for enhancing processing performance. These practices include guidelines on choosing a Mule runtime engine (Mule) version, avoiding certain app design issues, and specific settings for using Mule components and connectors.


== Mule Runtime Engine Version

Before you start tuning your application, review the following Mule version recommendations:

* Use the latest Mule version to create and run the application.
* Update your application dependencies to the latest version so you take advantage of the recent performance improvements and bug fixes.
* Update to the latest version of the Mule patch whenever possible.
* When developing and testing an application, use the same Mule version as used to deploy that application in your environments.

== Tips to Design for Enhanced Processing Performance


As you design your apps, consider the following recommendations to increase performance:

* Instead of using the Java module too many times to reuse some code (such as Java libraries), you can create an SDK module with operations that wrap Java invocations.
* Use DataWeave to transform/enrich the data, and create payloads instead of custom scripting code (Java, Groovy, etc).
* Avoid sequences of `set-variable/set-payload` components. See the following example:

[source,xml,linenums]
----
<set-variable value='"Hello"' doc:name="Set Variable" variableName="hello"/>
<set-variable value='"world!"' doc:name="Set Variable" variableName="world"/>
----

Instead, squash these components into a single `ee:transform` that avoids generating a new event for each component. See the following example:

[source,xml,linenums]
----
<ee:transform doc:name="Transform Message" >
	<ee:variables >
		<ee:set-variable variableName="hello" ><![CDATA[%dw 2.0
            output application/json
            ---
           "Hello"]]></ee:set-variable>

           <ee:set-variable variableName="world" ><![CDATA[%dw 2.0
            output application/json
            ---
           "world"]]></ee:set-variable>
	</ee:variables>
</ee:transform>
----

* Avoid store transient values to be used in `set-variable`. See the following example:

[source,xml,linenums]
----
<flow name="FileComponentWithsetVariableFlow" doc:id="daa9e38a-bb8c-4c87-a4c0-ba2dd90316b2" >
       <set-variable value="#['file_path/' ++ attributes.queryParams['filename']]" doc:name="Set Variable" doc:id="cf876447-12a6-4267-9b26-5e849153142c" variableName="fileName"/>
       <file:read doc:name="Read" doc:id="e4ad1ad4-0edb-45c9-ab43-d7f07effa277" path="#[vars.fileName]"/>
</flow>
----

Instead, inline these values into components that need them. See the following example:

[source,xml,linenums]
----
<flow name="FileComponentWithoutsetVariableFlow" doc:id="0d44d155-cabe-4a79-99e4-81de22743edb" >
      <file:read doc:name="Read" doc:id="09dfb229-67fd-4508-862f-489c123527ba" path="#['file_path/' ++ attributes.queryParams['filename']]"/>
</flow>
----

* Avoid creating property resolvers, which causes the usage DataWeave for every event, applying an overhead. See the following example:

[source,xml,linenums]
----
<flow-ref name="#[p(someProp) default p(otherProp)]"/>
----

Instead, place DataWeave logic in a property placeholder and use a static flow reference. See the following example:

[source,xml,linenums]
----
<flow-ref name="${propertyContainer.propertyName}"/>
----


== Components and Connectors

When designing your apps using Mule components and connectors, consider the following recommendations to enhance the performance.

=== APIkit

To obtain performance improvement, you can disable APIkit validations. In case payload validations are required, APIkit  validates input requests against API specification.

=== DataWeave
When using DataWeave consider the following:

* When dealing with large payloads, include the directive `indent=false` to improve the client's parsing performance and to reduce the response payload size.
* Define the input `content-type` to avoid verbose messages in the Log.
* Use inline DataWeave scripts on the development phase, then pass it to an external file to have a clean XML and reusable scripts.
* Do not log complex DataWeave expressions with every request.
* Avoid patterns of iterating over a collection and then transforming each individual item. See the following example:

[source,xml,linenums]
----
<foreach>
	<ee:transform >
		<ee:message >
			<ee:set-payload ><![CDATA[%dw 2.0
output application/json
---
payload mapObject (value, key) -> {
	(upper(key)): value
}
			]]></ee:set-payload>
		</ee:message>
	</ee:transform>
	...
</foreach>
----

Instead, transform the entire collection and iterate later. See the following example:

[source,xml,linenums]
----
<ee:transform>
	<ee:message >
		<ee:set-payload ><![CDATA[%dw 2.0
output application/json
---
payload map (item, index) -> {
	book: item mapObject (value, key) -> {
		(upper(key)): value
	}
}
		]]></ee:set-payload>
	</ee:message>
</ee:transform>
<foreach>
	...
</foreach>
----

=== Validator
Use Validator instead of throwing exceptions with Groovy Scripts.


===  HTTP(s)

For HTTP(s) consider the following recommendations:

* Use the authentication mechanisms provided by Anypoint Connector for HTTP (HTTP Connector) instead of doing it manually (for example, manually generating the Basic auth header with a DataWeave expression).
* If HTTPS is required, use the HTTPS Listener with a TLS Context reference, configuring the key-store with key-pair values generated with Keytool. The HTTPS configuration can be avoided if the SSL can also be terminated at the Load Balancer level when using a dedicated load balancer in CloudHub or if there is an on-premises load balancer for hybrid scenarios.

See the following example:
[source,xml,linenums]
----
<tls:context name="TLS_Context" doc:name="TLS Context">
      <tls:key-store type="jks" path="company-keystore.jks" alias="${jks.alias}" keyPassword="${jks.key.password}" password="${jks.password}"/>
</tls:context>
----

=== Database Connector
Use parameterized queries. Use dynamic queries only if you don't have another choice, remember to validate inputs previously. Using dynamic queries could cause SQL-Injection vulnerability.

=== File Connector

Instead of using a transform component for the transformation in the write operation, use a DataWeave expression. This avoids the message payload changes for the operations after the write. See the following example:

[source,xml,linenums]
----
<file:write path="output.csv">
 <file:content>#[%dw 2.0
                 output application/csv
                 ---
                 payload.customers.email
               ]
 </file:content>
</file:write>
----

Use the recursive parameter to list files and folders within subfolders. See the following example:

[source,xml,linenums]
----
<file:list config-ref="File_Config" directoryPath="relativePath" recursive="true" />
----


=== Web Service Consumer Connector
Import WSDLs including all references (XSDs) in your project, use Anypoint Connector for Web Service Consumer (Web Service Consumer Connector) and point the configuration to the local WSDL.

=== AMQP Connector

The server constrains the performance and configuration of the connector. Therefore, when you are investigating performance issues, you must explore the server-side configuration to determine if consume or publish parameters have an impact on the performance.

==== Consume Parameters

Review consume parameters that can have an impact on performance.

===== Number of Consumers
You can set the number of consumers for an AMQP configuration and the Listener source. It manages the number of consumers spawned by the source to receive AMQP messages concurrently, as each consumer creates and uses a different channel. +
The message throughput relates to the number of consumers, and it enhances if the number of consumers increases, but it is also conditioned to the performance characteristics of the flow.

===== Ack Mode
You can set acknowledgment mode (ACK) at the configuration level (Consumer tab). Listener and Consume operations can also override this mode. ACK mode determines the acknowledgment mode to use when consuming from the AMQP broker. There are three acknowledgment modes: +

* `AUTO` +
Use Automatic to acknowledge a received message automatically only if the flow execution finishes successfully.
* `MANUAL` +
Use Manual if you want the app logic to control message acknowledgment.
* `IMMEDIATE` +
Use Immediate when you want to acknowledge messages as your app consumes them, before processing them.

Note that if a transaction is opened in the channel, the ACK mode parameter is overruled and the commit handles automatically the message acknowledgment, also the rollback handles automatically the recovery.


===== Quality of Service Tab
You can set the following parameters at the configuration level (Quality of Service tab) with 0 as unlimited. Listener operation can also override the setting. These are the parameters:

* Prefetch Size +
Defines a prefetch size window. The broker sends as many messages as possible without exceeding the prefetch size window in octets (bytes).
* Prefetch Count +
Specifies a global prefetch window in terms of the max number of whole messages. This field may be used in combination with the `prefetch-size` field; a message will only be sent in advance if both prefetch windows allow it.

===== Ack Mode and Prefetch

Acknowledgment mode and QoS prefetch value have a significant effect on consumer throughput. In general, increasing prefetch improves the rate of message delivery to consumers. The Immediate acknowledgment mode yields the best possible rate of delivery. However, in both cases the number of delivered but not yet processed messages will also increase, therefore increasing consumer RAM consumption.

Automatic acknowledgement mode or Manual acknowledgment mode with unlimited prefetch should be used with care. Consumers that consume a lot of messages without acknowledging will lead to memory consumption growth on the broker node they are connected to. Finding a suitable prefetch value is a matter of trial and error and can vary from workload to workload.

==== Publish Parameters

You can set the following parameters at the configuration level (Publisher tab). Publish and Publish-consume operations can also override these parameters. If the use case requires it, you can enable only one of the recommendations:

===== Delivery Mode
It declares the delivery mode to use when publishing to the AMQP broker. Possible parameters values are:

* `PERSISTENT` +
Messages marked as persistent and delivered to durable queues are logged to disk on the broker.
* `TRANSIENT` +
No logging for the delivered message is performed.

The broker is responsible for the implementation of the recordable storage mechanism for persistent messages. The impact of this feature on performance depends on the AMQP server.

===== Request Broker Confirm
In case there is no confirmation provided by the broker, it dictates whether the operation must fail. Adds one extra communication between the broker and the client per message published.


== See Also
* xref:mule-app-properties-to-configure.adoc[Configure Property Placeholders]
* xref:mule-sdk::getting-started.adoc[Getting Started with the Mule SDK for Java]
* xref:connectors::http/http-connector.adoc[HTTP Connector]
* https://owasp.org/www-community/attacks/SQL_Injection[SQL Injection]
* https://www.rabbitmq.com/blog/2014/04/14/finding-bottlenecks-with-rabbitmq-3-3/[Finding bottlenecks with RabbitMQ 3.3]
